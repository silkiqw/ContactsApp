import Foundation
import Contacts
import ContactsUI

@objc public class Contacts: NSObject {
    private let plugin: ContactsPlugin

    private var displayCreateContactCompletion: ((DisplayCreateContactResult?, Error?) -> Void)?
    private var displayUpdateContactByIdCompletion: ((Error?) -> Void)?
    private var pickContactsCompletion: ((PickContactsResult?, Error?) -> Void)?
    private var pickContactsOptions: PickContactsOptions?

    init(plugin: ContactsPlugin) {
        self.plugin = plugin
    }

    @objc public func countContacts(completion: @escaping (_ result: CountContactsResult?, _ error: Error?) -> Void) {
        do {
            let store = CNContactStore()

            let keysToFetch: [CNKeyDescriptor] = [CNContactIdentifierKey as CNKeyDescriptor]
            let request = CNContactFetchRequest(keysToFetch: keysToFetch)

            var total = 0
            try store.enumerateContacts(with: request) { _, _ in
                total += 1
            }

            completion(CountContactsResult(total: total), nil)
        } catch let error {
            completion(nil, error)
        }
    }

    @objc public func createContact(_ options: CreateContactOptions, completion: @escaping (_ result: CreateContactResult?, _ error: Error?) -> Void) throws {
        let contact = CNMutableContact()

        // Birthday
        if let birthday = options.contact.birthday {
            contact.birthday = birthday.toDateComponents()
        }
        // Names
        if let givenName = options.contact.givenName {
            contact.givenName = givenName
        }
        if let middleName = options.contact.middleName {
            contact.middleName = middleName
        }
        if let familyName = options.contact.familyName {
            contact.familyName = familyName
        }
        if let namePrefix = options.contact.namePrefix {
            contact.namePrefix = namePrefix
        }
        if let nameSuffix = options.contact.nameSuffix {
            contact.nameSuffix = nameSuffix
        }
        // Note
        if let note = options.contact.note {
            contact.note = note
        }
        // Organization
        if let organizationName = options.contact.organizationName {
            contact.organizationName = organizationName
        }
        if let jobTitle = options.contact.jobTitle {
            contact.jobTitle = jobTitle
        }
        // Photo
        if let photo = options.contact.photo {
            // Remove data url prefix
            let photo = photo.replacingOccurrences(of: "^data:image/[^;]*;base64,", with: "", options: .regularExpression)
            // Convert base64 string to data
            if let data = Data(base64Encoded: photo, options: .ignoreUnknownCharacters) {
                contact.imageData = data
            }
        }
        // Email addresses
        if let emailAddresses = options.contact.emailAddresses {
            contact.emailAddresses = emailAddresses.map { $0.toCNLabeledValue() }
        }
        // Phone numbers
        if let phoneNumbers = options.contact.phoneNumbers {
            contact.phoneNumbers = phoneNumbers.map { $0.toCNLabeledValue() }
        }
        // Postal addresses
        if let postalAddresses = options.contact.postalAddresses {
            contact.postalAddresses = postalAddresses.map { $0.toCNLabeledValue() }
        }
        // Url addresses
        if let urlAddresses = options.contact.urlAddresses {
            contact.urlAddresses = urlAddresses.map { $0.toCNLabeledValue() }
        }

        let contactStore = CNContactStore()

        let saveRequest = CNSaveRequest()
        saveRequest.add(contact, toContainerWithIdentifier: nil)

        if let groupIds = options.contact.groupIds {
            let predicate = CNGroup.predicateForGroups(withIdentifiers: groupIds)
            let groups = try contactStore.groups(matching: predicate)

            for group in groups {
                saveRequest.addMember(contact, to: group)
            }
        }

        try contactStore.execute(saveRequest)

        if contact.isKeyAvailable(CNContactIdentifierKey) {
            let result = CreateContactResult(id: contact.identifier)
            completion(result, nil)
        } else {
            completion(nil, CustomError.unknown)
        }
    }

    @objc public func createGroup(_ options: CreateGroupOptions, completion: @escaping (_ result: CreateGroupResult?, _ error: Error?) -> Void) throws {
        let contactStore = CNContactStore()
        let group = CNMutableGroup()
        group.name = options.name

        let saveRequest = CNSaveRequest()
        saveRequest.add(group, toContainerWithIdentifier: nil)

        do {
            try contactStore.execute(saveRequest)
            completion(CreateGroupResult(group), nil)
        } catch let error {
            completion(nil, error)
        }
    }

    @objc public func displayContactById(_ options: DisplayContactByIdOptions, completion: @escaping (_ error: Error?) -> Void) throws {
        guard let viewController = plugin.bridge?.viewController else {
            completion(CustomError.unknown)
            return
        }

        let contactStore = CNContactStore()

        do {
            let requiredKeys = [CNContactViewController.descriptorForRequiredKeys()]
            let contact = try contactStore.unifiedContact(withIdentifier: options.id, keysToFetch: requiredKeys)
            let contactViewController = ContactDetailsViewController(for: contact)
            contactViewController.delegate = self

            Task { @MainActor in
                viewController.present(UINavigationController(rootViewController: contactViewController), animated: true) {
                    completion(nil)
                }
            }
        }
    }

    @objc public func displayCreateContact(_ options: DisplayCreateContactOptions, completion: @escaping (_ result: DisplayCreateContactResult?, _ error: Error?) -> Void) {
        guard let viewController = plugin.bridge?.viewController else {
            completion(nil, CustomError.unknown)
            return
        }

        let newContact = CNMutableContact()

        if let contact = options.contact {
            // Birthday
            if let birthday = contact.birthday {
                newContact.birthday = birthday.toDateComponents()
            }
            // Names
            if let givenName = contact.givenName {
                newContact.givenName = givenName
            }
            if let middleName = contact.middleName {
                newContact.middleName = middleName
            }
            if let familyName = contact.familyName {
                newContact.familyName = familyName
            }
            if let namePrefix = contact.namePrefix {
                newContact.namePrefix = namePrefix
            }
            if let nameSuffix = contact.nameSuffix {
                newContact.nameSuffix = nameSuffix
            }
            // Note
            if let note = contact.note {
                newContact.note = note
            }
            // Organization
            if let organizationName = contact.organizationName {
                newContact.organizationName = organizationName
            }
            if let jobTitle = contact.jobTitle {
                newContact.jobTitle = jobTitle
            }
            // Photo
            if let photo = contact.photo {
                // Remove data url prefix
                let photo = photo.replacingOccurrences(of: "^data:image/[^;]*;base64,", with: "", options: .regularExpression)
                // Convert base64 string to data
                if let data = Data(base64Encoded: photo, options: .ignoreUnknownCharacters) {
                    newContact.imageData = data
                }
            }
            // Email addresses
            if let emailAddresses = contact.emailAddresses {
                newContact.emailAddresses = emailAddresses.map { $0.toCNLabeledValue() }
            }
            // Phone numbers
            if let phoneNumbers = contact.phoneNumbers {
                newContact.phoneNumbers = phoneNumbers.map { $0.toCNLabeledValue() }
            }
            // Postal addresses
            if let postalAddresses = contact.postalAddresses {
                newContact.postalAddresses = postalAddresses.map { $0.toCNLabeledValue() }
            }
            // Url addresses
            if let urlAddresses = contact.urlAddresses {
                newContact.urlAddresses = urlAddresses.map { $0.toCNLabeledValue() }
            }
        }

        let contactViewController = CNContactViewController(forNewContact: newContact)
        contactViewController.delegate = self
        contactViewController.contactStore = CNContactStore()

        Task { @MainActor in
            viewController.present(UINavigationController(rootViewController: contactViewController), animated: true)
        }

        displayCreateContactCompletion = completion
    }

    @objc public func deleteContactById(_ options: DeleteContactByIdOptions, completion: @escaping (_ error: Error?) -> Void) {
        let contactStore = CNContactStore()

        do {
            let contact = try contactStore.unifiedContact(withIdentifier: options.id, keysToFetch: [CNContactIdentifierKey as CNKeyDescriptor])

            let saveRequest = CNSaveRequest()
            saveRequest.delete(contact.mutableCopy() as! CNMutableContact)

            try contactStore.execute(saveRequest)

            completion(nil)
        } catch {
            completion(CustomError.contactNotFound)
        }
    }

    @objc public func deleteGroupById(_ options: DeleteGroupByIdOptions, completion: @escaping (_ error: Error?) -> Void) {
        let contactStore = CNContactStore()
        let predicate = CNGroup.predicateForGroups(withIdentifiers: [options.id])

        do {
            let groups = try contactStore.groups(matching: predicate)

            if let group = groups.first, let mutableGroup = group.mutableCopy() as? CNMutableGroup {
                let deleteRequest = CNSaveRequest()
                deleteRequest.delete(mutableGroup)
                try contactStore.execute(deleteRequest)

                completion(nil)
                return
            }

            completion(CustomError.groupNotFound)
        } catch let error {
            completion(error)
        }
    }

    @objc public func displayUpdateContactById(_ options: DisplayUpdateContactByIdOptions, completion: @escaping (_ error: Error?) -> Void) {
        guard let viewController = plugin.bridge?.viewController else {
            completion(CustomError.unknown)
            return
        }

        let contactStore = CNContactStore()

        do {
            let requiredKeys = [CNContactViewController.descriptorForRequiredKeys()]
            let contact = try contactStore.unifiedContact(withIdentifier: options.id, keysToFetch: requiredKeys)
            let mutableContact = contact.mutableCopy() as! CNMutableContact

            let contactViewController = CNContactViewController(for: mutableContact)
            contactViewController.contactStore = contactStore
            contactViewController.allowsEditing = true
            contactViewController.allowsActions = false
            contactViewController.delegate = self

            Task { @MainActor in
                viewController.present(UINavigationController(rootViewController: contactViewController), animated: true)
            }

            displayUpdateContactByIdCompletion = completion
        } catch {
            completion(error)
        }
    }

    @objc public func getContactById(_ options: GetContactByIdOptions, completion: @escaping (_ result: GetContactByIdResult?, _ error: Error?) -> Void) {
        let contactStore = CNContactStore()

        do {
            let contactResult = try contactStore.unifiedContact(withIdentifier: options.id, keysToFetch: options.fields.map { $0.descriptor })

            var groupIds: [String]?
            if options.includeGroupIds {
                groupIds = try Contacts.getContactGroupIds(contactStore, contact: contactResult)
            }

            let contact = Contact(contactResult, includeId: options.includeId, id: nil, groupIds: groupIds)
            let result = GetContactByIdResult(contact: contact)

            completion(result, nil)
        } catch {
            // No contact found
            let result = GetContactByIdResult(contact: nil)

            completion(result, nil)
        }
    }

    @objc public func getContacts(_ options: GetContactsOptions, completion: @escaping (_ result: GetContactsResult?, _ error: Error?) -> Void) {
        let contactStore = CNContactStore()

        var contacts = [Contact]()
        var index = 0

        do {
            let fetchRequest = CNContactFetchRequest(keysToFetch: options.fields.map { $0.descriptor })
            fetchRequest.sortOrder = CNContactSortOrder.userDefault

            try contactStore.enumerateContacts(with: fetchRequest) { contact, stop in
                if index < options.offset {
                    index += 1
                    return
                }
                if contacts.count >= options.limit {
                    stop.pointee = true
                    return
                }

                do {
                    var groupIds: [String]?
                    if options.includeGroupIds {
                        groupIds = try Contacts.getContactGroupIds(contactStore, contact: contact)
                    }
                    contacts.append(Contact(contact, includeId: options.includeId, id: nil, groupIds: groupIds))
                } catch {
                    contacts.append(Contact(contact, includeId: options.includeId, id: nil, groupIds: nil))
                }
            }

            let result = GetContactsResult(contacts: contacts)
            completion(result, nil)
        } catch {
            completion(nil, error)
        }
    }

    @objc public func getGroupById(_ options: GetGroupByIdOptions, completion: @escaping (_ result: GetGroupByIdResult?, _ error: Error?) -> Void) {
        let contactStore = CNContactStore()
        let predicate = CNGroup.predicateForGroups(withIdentifiers: [options.id])

        do {
            let groups = try contactStore.groups(matching: predicate)
            if let group = groups.first {
                completion(GetGroupByIdResult(group: group), nil)
                return
            }

            completion(GetGroupByIdResult(group: nil), nil)
        } catch let error {
            completion(nil, error)
        }
    }

    @objc public func getGroups(completion: @escaping (_ result: GetGroupsResult?, _ error: Error?) -> Void) {
        let contactStore = CNContactStore()

        do {
            let groups = try contactStore.groups(matching: nil)
            completion(GetGroupsResult(groups: groups), nil)
        } catch let error {
            completion(nil, error)
        }
    }

    @objc public func pickContacts(_ options: PickContactsOptions, completion: @escaping (_ result: PickContactsResult?, _ error: Error?) -> Void) {
        guard let viewController = plugin.bridge?.viewController else {
            completion(nil, CustomError.unknown)
            return
        }

        pickContactsOptions = options

        DispatchQueue.main.async {
            let contactPickerViewController = CNContactPickerViewController()
            contactPickerViewController.delegate = self

            viewController.present(UINavigationController(rootViewController: contactPickerViewController), animated: true)

            self.pickContactsCompletion = completion
        }
    }

    @objc public func updateContactById(_ options: UpdateContactByIdOptions, completion: @escaping (_ error: Error?) -> Void) throws {
        let contactStore = CNContactStore()

        struct ContactFieldUpdate {
            let key: CNKeyDescriptor
            let update: (CNMutableContact) -> Void
        }
        var updates: [ContactFieldUpdate] = []

        // Birthday
        if let birthday = options.contact.birthday {
            updates.append(ContactFieldUpdate(key: ContactField.birthday.descriptor, update: { $0.birthday = birthday.toDateComponents() }))
        }
        // Names
        if let givenName = options.contact.givenName {
            updates.append(ContactFieldUpdate(key: ContactField.givenName.descriptor, update: { $0.givenName = givenName }))
        }
        if let middleName = options.contact.middleName {
            updates.append(ContactFieldUpdate(key: ContactField.middleName.descriptor, update: { $0.middleName = middleName }))
        }
        if let familyName = options.contact.familyName {
            updates.append(ContactFieldUpdate(key: ContactField.familyName.descriptor, update: { $0.familyName = familyName }))
        }
        if let namePrefix = options.contact.namePrefix {
            updates.append(ContactFieldUpdate(key: ContactField.namePrefix.descriptor, update: { $0.namePrefix = namePrefix }))
        }
        if let nameSuffix = options.contact.nameSuffix {
            updates.append(ContactFieldUpdate(key: ContactField.nameSuffix.descriptor, update: { $0.nameSuffix = nameSuffix }))
        }
        // Note
        if let note = options.contact.note {
            updates.append(ContactFieldUpdate(key: ContactField.note.descriptor, update: { $0.note = note }))
        }
        // Organization
        if let organizationName = options.contact.organizationName {
            updates.append(ContactFieldUpdate(key: ContactField.organizationName.descriptor, update: { $0.organizationName = organizationName }))
        }
        if let jobTitle = options.contact.jobTitle {
            updates.append(ContactFieldUpdate(key: ContactField.jobTitle.descriptor, update: { $0.jobTitle = jobTitle }))
        }
        // Photo
        if let photo = options.contact.photo {
            // Remove data url prefix
            let photo = photo.replacingOccurrences(of: "^data:image/[^;]*;base64,", with: "", options: .regularExpression)
            // Convert base64 string to data
            if let data = Data(base64Encoded: photo, options: .ignoreUnknownCharacters) {
                updates.append(ContactFieldUpdate(key: CNContactImageDataKey as CNKeyDescriptor, update: { $0.imageData = data }))
            }
        }
        // Email addresses
        if let emailAddresses = options.contact.emailAddresses {
            updates.append(ContactFieldUpdate(key: ContactField.emailAddresses.descriptor, update: { $0.emailAddresses = emailAddresses.map { $0.toCNLabeledValue() } }))
        }
        // Phone numbers
        if let phoneNumbers = options.contact.phoneNumbers {
            updates.append(ContactFieldUpdate(key: ContactField.phoneNumbers.descriptor, update: { $0.phoneNumbers = phoneNumbers.map { $0.toCNLabeledValue() } }))
        }
        // Postal addresses
        if let postalAddresses = options.contact.postalAddresses {
            updates.append(ContactFieldUpdate(key: ContactField.postalAddresses.descriptor, update: { $0.postalAddresses = postalAddresses.map { $0.toCNLabeledValue() } }))
        }
        // Url addresses
        if let urlAddresses = options.contact.urlAddresses {
            updates.append(ContactFieldUpdate(key: ContactField.urlAddresses.descriptor, update: { $0.urlAddresses = urlAddresses.map { urlAddress in
                return CNLabeledValue(
                    label: nil,
                    value: urlAddress.value as NSString
                )
            } }))
        }

        let keysToFetch = updates.map { $0.key } + [CNContactIdentifierKey as CNKeyDescriptor]
        let predicate = CNContact.predicateForContacts(withIdentifiers: [options.id])
        let contacts = try contactStore.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)

        guard let contact = contacts.first else {
            completion(CustomError.contactNotFound)
            return
        }

        let mutableContact = contact.mutableCopy() as! CNMutableContact

        updates.forEach { $0.update(mutableContact) }

        let saveRequest = CNSaveRequest()
        saveRequest.update(mutableContact)
        try contactStore.execute(saveRequest)

        // Groups
        if let groupIds = options.contact.groupIds {
            let allGroups = try contactStore.groups(matching: nil)
            let currentGroupIds = try Contacts.getContactGroupIds(contactStore, contact: contact)

            for groupId in currentGroupIds {
                if !groupIds.contains(groupId) {
                    if let group = allGroups.first(where: { $0.identifier == groupId }) {
                        saveRequest.removeMember(mutableContact, from: group)
                    }
                }
            }

            for groupId in groupIds {
                if let group = allGroups.first(where: { $0.identifier == groupId }), !currentGroupIds.contains(groupId) {
                    saveRequest.addMember(mutableContact, to: group)
                }
            }
        }

        completion(nil)
    }

    private static func getContactGroupIds(_ contactStore: CNContactStore, contact: CNContact) throws -> [String] {
        let groups = try contactStore.groups(matching: nil)
        var groupIds: [String] = []

        for group in groups {
            let predicate = CNContact.predicateForContactsInGroup(withIdentifier: group.identifier)
            let keysToFetch = [CNContactIdentifierKey as CNKeyDescriptor]
            let contactsInGroup = try contactStore.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)

            if contactsInGroup.contains(where: { $0.identifier == contact.identifier }) {
                groupIds.append(group.identifier)
            }
        }

        return groupIds
    }
}

extension Contacts: CNContactViewControllerDelegate {
    public func contactViewController(_ viewController: CNContactViewController, didCompleteWith contact: CNContact?) {
        // Dismiss the view controller
        viewController.dismiss(animated: true)
        // Resolve the plugin call
        if let completion = displayCreateContactCompletion {
            defer { displayCreateContactCompletion = nil }

            if let contact = contact {
                completion(DisplayCreateContactResult(id: contact.identifier), nil)
            } else {
                completion(nil, CustomError.displayCreateContactCanceled)
            }

            return
        }

        if let completion = displayUpdateContactByIdCompletion {
            defer { displayUpdateContactByIdCompletion = nil }

            if let _ = contact {
                completion(nil)
            } else {
                completion(CustomError.displayUpdateContactByIdCanceled)
            }
        }
    }
}

extension Contacts: CNContactPickerDelegate {
    public func contactPicker(_ viewController: CNContactPickerViewController, didSelect contact: CNContact) {
        viewController.dismiss(animated: true)

        if let completion = pickContactsCompletion, let options = pickContactsOptions {
            let contactWithFilteredFields = CNMutableContact()

            options.fields.forEach { $0.copy(from: contact, to: contactWithFilteredFields) }

            var groupIds: [String]?
            if options.includeGroupIds {
                do {
                    let contactStore = CNContactStore()
                    groupIds = try Contacts.getContactGroupIds(contactStore, contact: contact)
                } catch let error {
                    groupIds = nil
                }
            }

            let result = PickContactsResult(contact: Contact(contactWithFilteredFields, includeId: options.includeId, id: contact.identifier, groupIds: groupIds))
            completion(result, nil)
        }

        pickContactsCompletion = nil
        pickContactsOptions = nil
    }
}

class ContactDetailsViewController: CNContactViewController {
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        // Add a "Done" button
        self.navigationItem.leftBarButtonItem = .init(
            barButtonSystemItem: .done,
            target: self,
            action: #selector(self.doneTapped)
        )
    }

    @objc private func doneTapped() {
        dismiss(animated: true)
    }
}
